{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fortepyan","text":"<p>Fortepyan is a Python package designed for programmers who work with MIDI data. Its standout feature is the ability to visualize MIDI data in a pianoroll format, providing an intuitive and interactive way to work with musical data.</p> <p>Creating new midi files is as simple as creating a pandas dataframe. All you need is a couple of lines of code to create a new midi file from scratch.</p> <p><pre><code>import fortepyan as ff\nimport pandas as pd\nimport random\n\n# Create a dataframe with random values\ndf = pd.DataFrame(\n    {\n    \"start\": [it for it in range(0, 100)],\n    \"duration\": [1 for it in range(0, 100)],\n    \"pitch\": [random.randint(40, 90) for it in range(0, 100)],\n    \"velocity\": [random.randint(40, 90) for it in range(0, 100)],\n    }\n)\n\n# Create a MidiPiece object\nmidi_piece = ff.MidiPiece(df)\n</code></pre> You can also load existing midi files and work with them, visualize them, or even save a mp3/wav file with the audio of the midi file.</p> <pre><code># Load a midi file\nmidi_file_path = \"path/to/midi/file.mid\"\nmidi_piece = ff.MidiPiece.from_file(midi_file_path)\n\n# Visualize the midi file as a pianoroll\nff.view.draw_pianoroll_with_velocities(midi_piece)\n\n# Save the audio of the midi file as a mp3 file\nff.audio.midi_to_mp3(midi_piece, \"path/to/mp3/file.mp3\")\n</code></pre> <p>Installing Fortepyan is as simple as: <code>pip install fortepyan</code></p>"},{"location":"documentation/how_to_documentation/","title":"Fortepyan Documentation Guide","text":""},{"location":"documentation/how_to_documentation/#overview","title":"Overview","text":"<p>In Fortepyan, we are using mkdocstrings to automaticaly generate documentation directly from docstrings.</p> <p>We are using Google style format.</p>"},{"location":"documentation/how_to_documentation/#creating-new-pages","title":"Creating New Pages","text":"<ul> <li>Step 1: create a new .md file in the <code>docs/</code> directory.</li> <li>Step 2: edit the <code>mkdocs.yml</code> file and add the new page to the <code>nav</code> section.</li> <li>Learn more about how mkdocs works here.</li> </ul>"},{"location":"documentation/how_to_documentation/#writing-docstrings","title":"Writing Docstrings","text":"<p>trim method from the MidiPiece class is used as an example. <pre><code>\"\"\"\nTrim a segment of a MIDI piece based on specified start and finish parameters, with options for different slicing types.\n\nThis method modifies the MIDI piece by selecting a segment from it, based on the `start` and `finish` parameters.\nThe segment can be selected through different methods determined by `slice_type`. If `shift_time` is True,\nthe timing of notes in the trimmed segment will be shifted to start from zero.\n\nArgs:\n    start (float | int): The starting point of the segment. It's treated as a float for 'standard' or 'by_end' slicing types,\n                        and as an integer for 'index' slicing type.\n    finish (float | int): The ending point of the segment. Similar to `start`, it's treated as a float or an integer\n                        depending on the `slice_type`.\n    shift_time (bool, optional): Whether to shift note timings in the trimmed segment to start from zero. Default is True.\n    slice_type (str, optional): The method of slicing. Can be 'standard', 'by_end', or 'index'. Default is 'standard'. See note below.\n\nReturns:\n    MidiPiece: A new `MidiPiece` object representing the trimmed segment of the original MIDI piece.\n\nRaises:\n    ValueError: If `start` and `finish` are not integers when `slice_type` is 'index', or if `start` is larger than `finish`.\n    IndexError: If the indices are out of bounds for 'index' slicing type, or if no notes are found in the specified range for other types.\n    NotImplementedError: If the `slice_type` provided is not implemented.\n\nExamples:\n    Trimming using standard slicing:\n    &gt;&gt;&gt; midi_piece.trim(start=1.0, finish=5.0)\n\n    Trimming using index slicing:\n    &gt;&gt;&gt; midi_piece.trim(start=0, finish=10, slice_type=\"index\")\n\n    Trimming with time shift disabled:\n    &gt;&gt;&gt; midi_piece.trim(start=1.0, finish=5.0, shift_time=False)\n\n    An example of a trimmed MIDI piece:\n    ![Trimmed MIDI piece](../assets/random_midi_piece.png)\n\nSlice types:\n    The `slice_type` parameter determines how the start and finish parameters are interpreted. It can be one of the following:\n\n        'standard': Trims notes that start outside the [start, finish] range.\n\n        'by_end': Trims notes that end after the finish parameter.\n\n        'index': Trims notes based on their index in the DataFrame. The start and finish parameters are treated as integers\n\n\"\"\"\n...\n</code></pre> You can learn more about writing docstrings in the links above.</p>"},{"location":"documentation/how_to_documentation/#rendering-documentation","title":"Rendering Documentation","text":"<p>To visualize docstring changes:</p> <ol> <li>Insert the following line in the respective .md file: <pre><code>::: fortepyan.directory.module_name\n</code></pre></li> <li>For module specific options, you can use the following syntax: <pre><code>::: fortepyan.directory.module_name\n    options:\n        show_root_toc_entry: false\n</code></pre></li> <li>Run <code>mkdocs serve</code> in the terminal to render the documentation locally.</li> </ol> <p>Explore more options in the mkdocstrings documentation.</p>"},{"location":"documentation/midi_classes/","title":"Midi Dataclass","text":"<p>Classes used to represent MIDI data structures.</p>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiFile","title":"<code>MidiFile</code>  <code>dataclass</code>","text":"Source code in <code>fortepyan/midi/structures.py</code> <pre><code>@dataclass\nclass MidiFile:\n    path: Optional[str] = None\n    apply_sustain: bool = True\n    sustain_threshold: int = 62\n    df: pd.DataFrame = field(init=False)\n    raw_df: pd.DataFrame = field(init=False)\n    sustain: pd.DataFrame = field(init=False)\n    control_frame: pd.DataFrame = field(init=False, repr=False)\n    _midi: pretty_midi.PrettyMIDI = field(init=True, repr=False, default=None)\n\n    def __rich_repr__(self):\n        yield \"MidiFile\"\n        yield self.path\n        yield \"notes\", self.df.shape\n        yield \"sustain\", self.sustain.shape\n        yield \"minutes\", round(self.duration / 60, 2)\n\n    @property\n    def duration(self) -&gt; float:\n        return self._midi.get_end_time()\n\n    @property\n    def notes(self):\n        # This is not great/foolproof, but we already have files\n        # where the piano track is present on multiple \"programs\"/\"instruments\n        notes = sum([inst.notes for inst in self._midi.instruments], [])\n        return notes\n\n    @property\n    def control_changes(self):\n        # See the note for notes ^^\n        ccs = sum([inst.control_changes for inst in self._midi.instruments], [])\n        return ccs\n\n    def _load_midi_file(self):\n        # Extract CC data\n        self.control_frame = pd.DataFrame(\n            {\n                \"time\": [cc.time for cc in self.control_changes],\n                \"value\": [cc.value for cc in self.control_changes],\n                \"number\": [cc.number for cc in self.control_changes],\n            }\n        )\n\n        # Sustain CC is 64\n        ids = self.control_frame.number == 64\n        self.sustain = self.control_frame[ids].reset_index(drop=True)\n\n        # Extract notes\n        raw_df = pd.DataFrame(\n            {\n                \"pitch\": [note.pitch for note in self.notes],\n                \"velocity\": [note.velocity for note in self.notes],\n                \"start\": [note.start for note in self.notes],\n                \"end\": [note.end for note in self.notes],\n            }\n        )\n        self.raw_df = raw_df.sort_values(\"start\", ignore_index=True)\n\n        if self.apply_sustain:\n            self.df = midi_tools.apply_sustain(\n                df=self.raw_df,\n                sustain=self.sustain,\n                sustain_threshold=self.sustain_threshold,\n            )\n        else:\n            self.df = self.raw_df\n\n    def __post_init__(self):\n        if self.path:\n            # Read the MIDI object\n            self._midi = pretty_midi.PrettyMIDI(self.path)\n\n        # Otherwise _midi had to be provided as an argument\n        self._load_midi_file()\n\n    def __getitem__(self, index: slice) -&gt; MidiPiece:\n        return self.piece[index]\n\n    @property\n    def piece(self) -&gt; MidiPiece:\n        source = {\n            \"type\": \"MidiFile\",\n            \"path\": self.path,\n        }\n        out = MidiPiece(\n            df=self.df,\n            source=source,\n        )\n        return out\n\n    @classmethod\n    def from_file(cls, midi_file: IO) -&gt; \"MidiFile\":\n        \"\"\"\n        Generic wrapper for the pretty_midi.PrettyMIDI interface.\n\n        Args:\n            midi_file (str or file): Path or file pointer to a MIDI file.\n\n        Returns:\n            MidiFile: A new `MidiFile` object containing the input file.\n        \"\"\"\n        _midi = pretty_midi.PrettyMIDI(midi_file)\n\n        midi_file = cls(_midi=_midi)\n        return midi_file\n\n    @classmethod\n    def from_piece(cls, piece: MidiPiece) -&gt; \"MidiFile\":\n        _midi = pretty_midi.PrettyMIDI()\n\n        # 0 is piano\n        program = 0\n        instrument_name = \"fortepyan\"\n        instrument = pretty_midi.Instrument(program=program, name=instrument_name)\n\n        # Convert the DataFrame to a list of tuples to avoid pandas overhead in the loop\n        note_data = piece.df[[\"velocity\", \"pitch\", \"start\", \"end\"]].to_records(index=False)\n        # Now we can iterate through this array which is more efficient than DataFrame iterrows\n        for velocity, pitch, start, end in note_data:\n            note = pretty_midi.Note(\n                velocity=int(velocity),\n                pitch=int(pitch),\n                start=start,\n                end=end,\n            )\n            instrument.notes.append(note)\n\n        _midi.instruments.append(instrument)\n\n        midi_file = cls(_midi=_midi)\n\n        return midi_file\n\n    @classmethod\n    def merge_files(cls, midi_files: list[\"MidiFile\"], space: float = 0.0) -&gt; \"MidiFile\":\n        \"\"\"\n        Merges multiple MIDI files into a single MIDI file.\n\n        This method combines the notes and control changes from the input list of\n        `MidiFile` objects into a single MIDI track with an optional space between\n        each file's content. All input files are assumed to have a piano track\n        (`program=0`) as the first instrument.\n\n        Args:\n            midi_files (list[MidiFile]): List of `MidiFile` objects to be merged.\n            space (float, optional): Time (in seconds) to insert between the end of\n                one MIDI file and the start of the next. Defaults to 0.0.\n\n        Returns:\n            MidiFile: A new `MidiFile` object containing the merged tracks.\n\n        Note:\n            - Only the first instrument (assumed to be a piano track) from each file\n              is processed.\n            - The last control change time is considered to calculate the start offset\n              for the next file. If there are no control changes, the last note end\n              time is used.\n        \"\"\"\n\n        _midi = pretty_midi.PrettyMIDI()\n\n        # 0 is piano\n        program = 0\n        instrument_name = \"fortepyan\"\n        instrument = pretty_midi.Instrument(program=program, name=instrument_name)\n\n        start_offset = 0\n        notes = []\n        control_changes = []\n        for midi_file in midi_files:\n            piano_track = midi_file._midi.instruments[0]\n            for note in piano_track.notes:\n                new_note = pretty_midi.Note(\n                    start=note.start + start_offset,\n                    end=note.end + start_offset,\n                    pitch=note.pitch,\n                    velocity=note.velocity,\n                )\n                notes.append(new_note)\n\n            for cc in piano_track.control_changes:\n                new_cc = pretty_midi.ControlChange(\n                    number=cc.number,\n                    value=cc.value,\n                    time=cc.time + start_offset,\n                )\n                control_changes.append(new_cc)\n\n            # Events from the next file have to be shifted to start later\n            last_cc_time = control_changes[-1].time if control_changes else 0\n            start_offset = max(notes[-1].end, last_cc_time) + space\n\n        instrument.notes = notes\n        instrument.control_changes = control_changes\n        _midi.instruments.append(instrument)\n\n        midi_file = cls(_midi=_midi)\n\n        return midi_file\n\n    def write(self, filename):\n        self._midi.write(filename)\n</code></pre>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiFile.from_file","title":"<code>from_file(midi_file)</code>  <code>classmethod</code>","text":"<p>Generic wrapper for the pretty_midi.PrettyMIDI interface.</p> <p>Parameters:</p> Name Type Description Default <code>midi_file</code> <code>str or file</code> <p>Path or file pointer to a MIDI file.</p> required <p>Returns:</p> Name Type Description <code>MidiFile</code> <code>MidiFile</code> <p>A new <code>MidiFile</code> object containing the input file.</p> Source code in <code>fortepyan/midi/structures.py</code> <pre><code>@classmethod\ndef from_file(cls, midi_file: IO) -&gt; \"MidiFile\":\n    \"\"\"\n    Generic wrapper for the pretty_midi.PrettyMIDI interface.\n\n    Args:\n        midi_file (str or file): Path or file pointer to a MIDI file.\n\n    Returns:\n        MidiFile: A new `MidiFile` object containing the input file.\n    \"\"\"\n    _midi = pretty_midi.PrettyMIDI(midi_file)\n\n    midi_file = cls(_midi=_midi)\n    return midi_file\n</code></pre>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiFile.merge_files","title":"<code>merge_files(midi_files, space=0.0)</code>  <code>classmethod</code>","text":"<p>Merges multiple MIDI files into a single MIDI file.</p> <p>This method combines the notes and control changes from the input list of <code>MidiFile</code> objects into a single MIDI track with an optional space between each file's content. All input files are assumed to have a piano track (<code>program=0</code>) as the first instrument.</p> <p>Parameters:</p> Name Type Description Default <code>midi_files</code> <code>list[MidiFile]</code> <p>List of <code>MidiFile</code> objects to be merged.</p> required <code>space</code> <code>float</code> <p>Time (in seconds) to insert between the end of one MIDI file and the start of the next. Defaults to 0.0.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>MidiFile</code> <code>MidiFile</code> <p>A new <code>MidiFile</code> object containing the merged tracks.</p> Note <ul> <li>Only the first instrument (assumed to be a piano track) from each file   is processed.</li> <li>The last control change time is considered to calculate the start offset   for the next file. If there are no control changes, the last note end   time is used.</li> </ul> Source code in <code>fortepyan/midi/structures.py</code> <pre><code>@classmethod\ndef merge_files(cls, midi_files: list[\"MidiFile\"], space: float = 0.0) -&gt; \"MidiFile\":\n    \"\"\"\n    Merges multiple MIDI files into a single MIDI file.\n\n    This method combines the notes and control changes from the input list of\n    `MidiFile` objects into a single MIDI track with an optional space between\n    each file's content. All input files are assumed to have a piano track\n    (`program=0`) as the first instrument.\n\n    Args:\n        midi_files (list[MidiFile]): List of `MidiFile` objects to be merged.\n        space (float, optional): Time (in seconds) to insert between the end of\n            one MIDI file and the start of the next. Defaults to 0.0.\n\n    Returns:\n        MidiFile: A new `MidiFile` object containing the merged tracks.\n\n    Note:\n        - Only the first instrument (assumed to be a piano track) from each file\n          is processed.\n        - The last control change time is considered to calculate the start offset\n          for the next file. If there are no control changes, the last note end\n          time is used.\n    \"\"\"\n\n    _midi = pretty_midi.PrettyMIDI()\n\n    # 0 is piano\n    program = 0\n    instrument_name = \"fortepyan\"\n    instrument = pretty_midi.Instrument(program=program, name=instrument_name)\n\n    start_offset = 0\n    notes = []\n    control_changes = []\n    for midi_file in midi_files:\n        piano_track = midi_file._midi.instruments[0]\n        for note in piano_track.notes:\n            new_note = pretty_midi.Note(\n                start=note.start + start_offset,\n                end=note.end + start_offset,\n                pitch=note.pitch,\n                velocity=note.velocity,\n            )\n            notes.append(new_note)\n\n        for cc in piano_track.control_changes:\n            new_cc = pretty_midi.ControlChange(\n                number=cc.number,\n                value=cc.value,\n                time=cc.time + start_offset,\n            )\n            control_changes.append(new_cc)\n\n        # Events from the next file have to be shifted to start later\n        last_cc_time = control_changes[-1].time if control_changes else 0\n        start_offset = max(notes[-1].end, last_cc_time) + space\n\n    instrument.notes = notes\n    instrument.control_changes = control_changes\n    _midi.instruments.append(instrument)\n\n    midi_file = cls(_midi=_midi)\n\n    return midi_file\n</code></pre>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiPiece","title":"<code>MidiPiece</code>  <code>dataclass</code>","text":"<p>A data class representing a piece of MIDI music, encapsulated in a Pandas DataFrame.</p> <p>This class provides functionalities for managing MIDI data, including methods to manipulate and represent the MIDI piece. The data is primarily stored in a Pandas DataFrame (<code>df</code>) which contains columns like 'start', 'end', 'duration', 'pitch', and 'velocity', essential for MIDI data representation. The class also includes source information for additional context.</p> <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The DataFrame containing the MIDI data.</p> <code>source</code> <code>dict</code> <p>Additional information about the MIDI piece's source. Defaults to None.</p> <p>Examples:</p> <p>Creating a MidiPiece instance:</p> <pre><code>&gt;&gt;&gt; midi_piece = MidiPiece(df=my_midi_df)\n</code></pre> Source code in <code>fortepyan/midi/structures.py</code> <pre><code>@dataclass\nclass MidiPiece:\n    \"\"\"\n    A data class representing a piece of MIDI music, encapsulated in a Pandas DataFrame.\n\n    This class provides functionalities for managing MIDI data, including methods to manipulate and represent the MIDI piece.\n    The data is primarily stored in a Pandas DataFrame (`df`) which contains columns like 'start', 'end', 'duration',\n    'pitch', and 'velocity', essential for MIDI data representation. The class also includes source information for\n    additional context.\n\n    Attributes:\n        df (pd.DataFrame): The DataFrame containing the MIDI data.\n        source (dict, optional): Additional information about the MIDI piece's source. Defaults to None.\n\n    Examples:\n        Creating a MidiPiece instance:\n        &gt;&gt;&gt; midi_piece = MidiPiece(df=my_midi_df)\n\n    \"\"\"\n\n    df: pd.DataFrame\n    source: dict = None\n\n    def __rich_repr__(self):\n        yield \"MidiPiece\"\n        yield \"notes\", self.df.shape\n        yield \"minutes\", round(self.duration / 60, 2)\n\n    def __post_init__(self):\n        # Ensure at least two of the three timing columns are present\n        timing_columns = {\"start\", \"end\", \"duration\"}\n        if sum(col in self.df.columns for col in timing_columns) &lt; 2:\n            raise ValueError(\"The DataFrame must have at least two of the following columns: 'start', 'end', 'duration'.\")\n\n        # Calculate the missing timing column if necessary\n        if \"start\" not in self.df.columns:\n            self.df[\"start\"] = self.df[\"end\"] - self.df[\"duration\"]\n        elif \"end\" not in self.df.columns:\n            self.df[\"end\"] = self.df[\"start\"] + self.df[\"duration\"]\n        elif \"duration\" not in self.df.columns:\n            self.df[\"duration\"] = self.df[\"end\"] - self.df[\"start\"]\n\n        # Convert timing columns to float to ensure consistency\n        for col in timing_columns:\n            self.df[col] = self.df[col].astype(float)\n\n        # Check for the absolutely required columns: 'pitch' and 'velocity'\n        if \"pitch\" not in self.df.columns:\n            raise ValueError(\"The DataFrame is missing the required column: 'pitch'.\")\n        if \"velocity\" not in self.df.columns:\n            raise ValueError(\"The DataFrame is missing the required column: 'velocity'.\")\n\n        if not self.source:\n            self.source = {\n                \"start\": 0,\n                \"finish\": self.size,\n            }\n\n    @property\n    def size(self) -&gt; int:\n        return self.df.shape[0]\n\n    def copy(self) -&gt; \"MidiPiece\":\n        notes_df = self.df.copy()\n        source = self.source.copy()\n        piece = MidiPiece(\n            df=notes_df,\n            source=source,\n        )\n        return piece\n\n    def time_shift(self, shift_s: float) -&gt; \"MidiPiece\":\n        \"\"\"\n        Shift the start and end times of all notes in the MidiPiece by a specified amount.\n\n        This method adjusts the start and end times of every note in the MidiPiece by adding the specified shift amount\n        `shift_s`. This can be used to move the entire piece forward or backward in time.\n\n        Args:\n            shift_s (float): The amount of time (in seconds) to shift the start and end times of the notes.\n                        Positive values shift the piece forward, and negative values shift it backward.\n\n        Examples:\n            Shifting the entire piece forward by 2 seconds:\n            &gt;&gt;&gt; midi_piece.time_shift(2.0)\n\n            Shifting the entire piece backward by 0.5 seconds:\n            &gt;&gt;&gt; midi_piece.time_shift(-0.5)\n\n        Returns:\n            - A new MidiPiece object after shifting\n        \"\"\"\n        source = dict(self.source)\n        source[\"time_shift\"] = source.get(\"time_shift\", 0) + shift_s\n\n        new_piece = MidiPiece(\n            df=self.df.copy(),\n            source=source,\n        )\n\n        new_piece.df.start += shift_s\n        new_piece.df.end += shift_s\n        return new_piece\n\n    @classmethod\n    def empty(cls) -&gt; \"MidiPiece\":\n        df = pd.DataFrame(columns=[\"start\", \"duration\", \"velocity\", \"pitch\"])\n        piece = cls(df=df)\n        return piece\n\n    def trim(\n        self,\n        start: float,\n        finish: float,\n    ) -&gt; \"MidiPiece\":\n        ids = (self.df.start &gt;= start) &amp; (self.df.start &lt;= finish)\n\n        idx = np.where(ids)[0]\n        if len(idx) == 0:\n            return MidiPiece.empty()\n\n        start_idx = idx[0]\n        finish_idx = idx[-1] + 1\n\n        slice_obj = slice(start_idx, finish_idx)\n\n        out_piece = self.__getitem__(slice_obj)\n\n        # Let the user see the start:finish window as the new 0:duration view\n        out_piece.df.start -= start\n        out_piece.df.end -= start\n\n        return out_piece\n\n    def __sanitize_get_index(self, index: slice) -&gt; slice:\n        \"\"\"\n        Sanitize and adjust the provided slice index for the MIDI file object.\n\n        This private method ensures that the slice provided is valid for slicing a MIDI file object. It adjusts the slice\n        to handle scenarios where only one bound (start or stop) is provided. If no start is specified, it defaults to 0.\n        If no stop is specified, it defaults to the size of the MIDI file.\n\n        Parameters:\n            index (slice): The slice object to be sanitized and adjusted. It must be a slice object.\n\n        Returns:\n            slice: The sanitized and possibly adjusted slice object.\n\n        Raises:\n            TypeError: If the provided index is not a slice object.\n\n        Examples:\n            - Getting a part of the MIDI file from the beginning up to a stop point:\n                &gt;&gt;&gt; midi_file.__sanitize_get_index(slice(None, 10))\n\n            - Getting a part of the MIDI file from a start point to the end:\n                &gt;&gt;&gt; midi_file.__sanitize_get_index(slice(5, None))\n\n        Note:\n        - This method is intended for internal use within the class and should not be called directly from outside the class.\n        \"\"\"\n        if not isinstance(index, slice):\n            raise TypeError(\"You can only get a part of MidiFile that has multiple notes: Index must be a slice\")\n\n        # If you want piece[:stop]\n        if not index.start:\n            index = slice(0, index.stop)\n\n        # If you want piece[start:]\n        if not index.stop:\n            index = slice(index.start, self.size)\n\n        return index\n\n    def __getitem__(self, index: slice) -&gt; \"MidiPiece\":\n        \"\"\"\n        Get a slice of the MIDI piece, optionally shifting the time of notes.\n\n        This method returns a segment of the MIDI piece based on the provided index. It sanitizes the index using the\n        `__sanitize_get_index` method. The method also keeps track of the original piece's information\n        in the sliced piece's source data.\n\n        Args:\n            index (slice): The slicing index to select a part of the MIDI piece. It must be a slice object.\n\n        Returns:\n            MidiPiece: A new `MidiPiece` object representing the sliced segment of the original MIDI piece.\n\n        Raises:\n            TypeError: If the provided index is not a slice object (handled in `__sanitize_get_index`).\n\n        Examples:\n            Getting a slice from the MIDI file with time shift:\n                &gt;&gt;&gt; midi_piece[0:10]\n\n        Note:\n            The `__getitem__` method is a special method in Python used for indexing or slicing objects. In this class,\n        it is used to get a slice of a MIDI piece.\n        \"\"\"\n        index = self.__sanitize_get_index(index)\n        part_df = self.df[index].reset_index(drop=True)\n\n        # Make sure the piece can always be tracked back to the original file exactly\n        out_source = dict(self.source)\n        out_source[\"start\"] = self.source.get(\"start\", 0) + int(index.start)\n        out_source[\"finish\"] = self.source.get(\"start\", 0) + int(index.stop)\n        out = MidiPiece(df=part_df, source=out_source)\n\n        return out\n\n    def __add__(self, other: \"MidiPiece\") -&gt; \"MidiPiece\":\n        \"\"\"\n        Combine this MidiPiece with another MidiPiece, adjusting the time stamps.\n\n        This method overloads the `+` operator for MidiPiece objects. It concatenates the DataFrame of the current object\n        with that of another MidiPiece, adjusting the start and end times of notes in the second piece so that they follow\n        sequentially after the first piece. A warning is raised to inform the user that the resulting piece may not be\n        musically valid.\n\n        Parameters:\n            other (MidiPiece): Another MidiPiece object to add to the current one.\n\n        Returns:\n            MidiPiece: A new MidiPiece object that represents the combination of the two MidiPieces.\n\n        Raises:\n            TypeError: If the object being added is not an instance of MidiPiece.\n\n        Examples:\n            Adding two MidiPiece objects:\n            &gt;&gt;&gt; combined_piece = midi_piece1 + midi_piece2\n\n        Note:\n            - The method ensures that the original MidiPiece objects are not modified during the addition.\n            - A UserWarning is raised to indicate that the resulting piece might not be musically valid.\n        \"\"\"\n        if not isinstance(other, MidiPiece):\n            raise TypeError(\"You can only add MidiPiece objects to other MidiPiece objects.\")\n\n        # Adjust the start/end times of the second piece\n        other.df.start += self.end\n        other.df.end += self.end\n\n        # Concatenate the two pieces\n        df = pd.concat([self.df, other.df], ignore_index=True)\n\n        # make sure the other piece is not modified\n        other.df.start -= self.end\n        other.df.end -= self.end\n\n        # make sure that start and end times are floats\n        df.start = df.start.astype(float)\n        df.end = df.end.astype(float)\n\n        out = MidiPiece(df=df)\n\n        # TODO Think of another way to track this information\n        # maybe add {\"warnings\": [\"merged from multiple pieces\"]} to .source?\n        # Show warning as the piece might not be musically valid.\n        # showwarning(\n        #     message=\"The resulting piece may not be musically valid.\",\n        #     category=UserWarning,\n        #     filename=\"fortepyan/midi/structures.py\",\n        #     lineno=280,\n        # )\n\n        return out\n\n    def __len__(self) -&gt; int:\n        return self.size\n\n    @property\n    def duration(self) -&gt; float:\n        duration = self.df.end.max() - self.df.start.min()\n        return duration\n\n    @property\n    def end(self) -&gt; float:\n        return self.df_with_end.end.max()\n\n    @property\n    def df_with_end(self) -&gt; pd.DataFrame:\n        df = self.df.copy()\n        df[\"end\"] = df.start + df.duration\n        return df\n\n    def to_midi(self, instrument_name: str = \"Piano\") -&gt; \"MidiFile\":\n        \"\"\"\n        Converts the note data stored in this object into a MIDI track using the specified instrument.\n\n        This function creates a MIDI track with notes defined by the object's data.\n        It uses the MidiFile to construct the track and the notes within it.\n\n        Args:\n            instrument_name (str, optional):\n                The name of the track's instrument. Defaults to \"Piano\".\n\n        Returns:\n            MidiFile:\n                A MidiFile object representing the MIDI track created from the note data. This object can be\n                further manipulated or directly written to a MIDI file.\n\n        Examples:\n            &gt;&gt;&gt; track = my_object.to_midi(\"Violin\")\n            This would create a MIDI track using the notes in 'my_object' and name it \"Violin\".\n\n        \"\"\"\n        return MidiFile.from_piece(self)\n\n    @classmethod\n    def from_huggingface(cls, record: dict) -&gt; \"MidiPiece\":\n        df = pd.DataFrame(record[\"notes\"])\n        df[\"duration\"] = df.end - df.start\n\n        source = json.loads(record[\"source\"])\n        that = cls(df=df, source=source)\n        return that\n\n    @classmethod\n    def from_file(cls, path: str) -&gt; \"MidiPiece\":\n        piece = MidiFile(str(path)).piece\n        return piece\n</code></pre>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiPiece.time_shift","title":"<code>time_shift(shift_s)</code>","text":"<p>Shift the start and end times of all notes in the MidiPiece by a specified amount.</p> <p>This method adjusts the start and end times of every note in the MidiPiece by adding the specified shift amount <code>shift_s</code>. This can be used to move the entire piece forward or backward in time.</p> <p>Parameters:</p> Name Type Description Default <code>shift_s</code> <code>float</code> <p>The amount of time (in seconds) to shift the start and end times of the notes.         Positive values shift the piece forward, and negative values shift it backward.</p> required <p>Examples:</p> <p>Shifting the entire piece forward by 2 seconds:</p> <pre><code>&gt;&gt;&gt; midi_piece.time_shift(2.0)\n</code></pre> <p>Shifting the entire piece backward by 0.5 seconds:</p> <pre><code>&gt;&gt;&gt; midi_piece.time_shift(-0.5)\n</code></pre> <p>Returns:</p> Type Description <code>MidiPiece</code> <ul> <li>A new MidiPiece object after shifting</li> </ul> Source code in <code>fortepyan/midi/structures.py</code> <pre><code>def time_shift(self, shift_s: float) -&gt; \"MidiPiece\":\n    \"\"\"\n    Shift the start and end times of all notes in the MidiPiece by a specified amount.\n\n    This method adjusts the start and end times of every note in the MidiPiece by adding the specified shift amount\n    `shift_s`. This can be used to move the entire piece forward or backward in time.\n\n    Args:\n        shift_s (float): The amount of time (in seconds) to shift the start and end times of the notes.\n                    Positive values shift the piece forward, and negative values shift it backward.\n\n    Examples:\n        Shifting the entire piece forward by 2 seconds:\n        &gt;&gt;&gt; midi_piece.time_shift(2.0)\n\n        Shifting the entire piece backward by 0.5 seconds:\n        &gt;&gt;&gt; midi_piece.time_shift(-0.5)\n\n    Returns:\n        - A new MidiPiece object after shifting\n    \"\"\"\n    source = dict(self.source)\n    source[\"time_shift\"] = source.get(\"time_shift\", 0) + shift_s\n\n    new_piece = MidiPiece(\n        df=self.df.copy(),\n        source=source,\n    )\n\n    new_piece.df.start += shift_s\n    new_piece.df.end += shift_s\n    return new_piece\n</code></pre>"},{"location":"documentation/midi_classes/#fortepyan.midi.structures.MidiPiece.to_midi","title":"<code>to_midi(instrument_name='Piano')</code>","text":"<p>Converts the note data stored in this object into a MIDI track using the specified instrument.</p> <p>This function creates a MIDI track with notes defined by the object's data. It uses the MidiFile to construct the track and the notes within it.</p> <p>Parameters:</p> Name Type Description Default <code>instrument_name</code> <code>str</code> <p>The name of the track's instrument. Defaults to \"Piano\".</p> <code>'Piano'</code> <p>Returns:</p> Name Type Description <code>MidiFile</code> <code>MidiFile</code> <p>A MidiFile object representing the MIDI track created from the note data. This object can be further manipulated or directly written to a MIDI file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; track = my_object.to_midi(\"Violin\")\nThis would create a MIDI track using the notes in 'my_object' and name it \"Violin\".\n</code></pre> Source code in <code>fortepyan/midi/structures.py</code> <pre><code>def to_midi(self, instrument_name: str = \"Piano\") -&gt; \"MidiFile\":\n    \"\"\"\n    Converts the note data stored in this object into a MIDI track using the specified instrument.\n\n    This function creates a MIDI track with notes defined by the object's data.\n    It uses the MidiFile to construct the track and the notes within it.\n\n    Args:\n        instrument_name (str, optional):\n            The name of the track's instrument. Defaults to \"Piano\".\n\n    Returns:\n        MidiFile:\n            A MidiFile object representing the MIDI track created from the note data. This object can be\n            further manipulated or directly written to a MIDI file.\n\n    Examples:\n        &gt;&gt;&gt; track = my_object.to_midi(\"Violin\")\n        This would create a MIDI track using the notes in 'my_object' and name it \"Violin\".\n\n    \"\"\"\n    return MidiFile.from_piece(self)\n</code></pre>"},{"location":"documentation/rendering/","title":"Rendering","text":"<p>These functions provide a simple interface to render audio files from MIDI representations.</p>"},{"location":"documentation/rendering/#fortepyan.audio.render.midi_to_mp3","title":"<code>midi_to_mp3(midi, mp3_path=None)</code>","text":"<p>Converts a MIDI file to an MP3 file.</p> <p>This function takes a MIDI object, either as a <code>MidiFile</code> object or a <code>MidiPiece</code> object, and first converts it to a WAV file. It then converts this WAV file to an MP3 file.</p> <p>Parameters:</p> Name Type Description Default <code>midi</code> <code>Union[MidiFile, MidiPiece]</code> <p>The MIDI file to convert. Can be either a <code>ff.MidiFile</code> object or a <code>MidiPiece</code> object.</p> required <code>mp3_path</code> <code>str</code> <p>The path where the converted MP3 file will be saved. If not specified, a temporary file is created.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>mp3_path</code> <code>str</code> <p>The path to the created MP3 file.</p> Note <p>If a <code>MidiPiece</code> object is provided, it is first converted to a <code>MidiFile</code> object before proceeding with the WAV and then MP3 conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; some_midi = ff.MidiPiece(midi_df)\n&gt;&gt;&gt; mp3_path = midi_to_mp3(some_midi, \"test.mp3\")\n&gt;&gt;&gt; print(\"MP3 file created at:\", mp3_path)\n</code></pre> Source code in <code>fortepyan/audio/render.py</code> <pre><code>def midi_to_mp3(midi: Union[structures.MidiFile, structures.MidiPiece], mp3_path: str = None):\n    \"\"\"\n    Converts a MIDI file to an MP3 file.\n\n    This function takes a MIDI object, either as a `MidiFile` object or a `MidiPiece` object,\n    and first converts it to a WAV file. It then converts this WAV file to an MP3 file.\n\n    Args:\n        midi (Union[MidiFile, MidiPiece]):\n            The MIDI file to convert. Can be either a `ff.MidiFile` object or a `MidiPiece` object.\n        mp3_path (str, optional):\n            The path where the converted MP3 file will be saved. If not specified, a temporary file is created.\n\n    Returns:\n        mp3_path (str): The path to the created MP3 file.\n\n    Note:\n        If a `MidiPiece` object is provided, it is first converted to a `MidiFile` object\n        before proceeding with the WAV and then MP3 conversion.\n\n\n    Examples:\n        &gt;&gt;&gt; some_midi = ff.MidiPiece(midi_df)\n        &gt;&gt;&gt; mp3_path = midi_to_mp3(some_midi, \"test.mp3\")\n        &gt;&gt;&gt; print(\"MP3 file created at:\", mp3_path)\n    \"\"\"\n    if isinstance(midi, structures.MidiPiece):\n        midi = midi.to_midi()\n\n    # This will be deleted\n    tmp_wav_path = tempfile.mkstemp(suffix=\".wav\")[1]\n    midi_to_wav(midi=midi, wavpath=tmp_wav_path)\n\n    # Wav to mp3\n    if not mp3_path:\n        mp3_path = tempfile.mkstemp(suffix=\".mp3\")[1]\n\n    print(\"Rendering audio to file:\", mp3_path)\n    AudioSegment.from_wav(tmp_wav_path).export(mp3_path, format=\"mp3\")\n\n    return mp3_path\n</code></pre>"},{"location":"documentation/rendering/#fortepyan.audio.render.midi_to_wav","title":"<code>midi_to_wav(midi, wavpath)</code>","text":"<p>Converts a MIDI file to a WAV file.</p> <p>This function takes a MIDI object, either as a <code>ff.MidiFile</code> object or a <code>MidiPiece</code> object, and converts it to a WAV file. The conversion uses the FluidSynth synthesizer with a downloaded sound font. The function also adds a silent event at the end of the MIDI sequence to ensure that the final notes have time to ring out properly.</p> <p>Parameters:</p> Name Type Description Default <code>midi</code> <code>Union[MidiFile, MidiPiece]</code> <p>The MIDI file to convert. Can be either a <code>MidiFile</code> object or a <code>MidiPiece</code> object.</p> required <code>wavpath</code> <code>str</code> <p>The path where the converted WAV file will be saved.</p> required Note <p>If a <code>MidiPiece</code> object is provided, it is first converted to a <code>MidiFile</code> object before proceeding with the WAV conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; some_midi = ff.MidiPiece(midi_df)\n&gt;&gt;&gt; midi_to_wav(some_midi, \"test.wav\")\n</code></pre> Source code in <code>fortepyan/audio/render.py</code> <pre><code>def midi_to_wav(midi: Union[structures.MidiFile, structures.MidiPiece], wavpath: str):\n    \"\"\"\n    Converts a MIDI file to a WAV file.\n\n    This function takes a MIDI object, either as a `ff.MidiFile` object or a `MidiPiece` object,\n    and converts it to a WAV file. The conversion uses the FluidSynth synthesizer with a downloaded sound font.\n    The function also adds a silent event at the end of the MIDI sequence to ensure that the final notes have time\n    to ring out properly.\n\n    Args:\n        midi (Union[MidiFile, MidiPiece]):\n            The MIDI file to convert. Can be either a `MidiFile` object or a `MidiPiece` object.\n        wavpath (str):\n            The path where the converted WAV file will be saved.\n\n    Note:\n        If a `MidiPiece` object is provided, it is first converted to a `MidiFile` object\n        before proceeding with the WAV conversion.\n\n\n    Examples:\n        &gt;&gt;&gt; some_midi = ff.MidiPiece(midi_df)\n        &gt;&gt;&gt; midi_to_wav(some_midi, \"test.wav\")\n    \"\"\"\n    if isinstance(midi, structures.MidiPiece):\n        midi = midi.to_midi()\n\n    # This will be deleted\n    tmp_midi_path = tempfile.mkstemp(suffix=\".mid\")[1]\n\n    # Add an silent event to make sure the final notes\n    # have time to ring out\n    end_time = midi.duration + 0.2\n    pedal_off = pretty_midi.ControlChange(64, 0, end_time)\n\n    midi._midi.instruments[0].control_changes.append(pedal_off)\n\n    midi.write(tmp_midi_path)\n\n    sound_font_path = soundfont.download_if_needed()\n    synth = FluidSynth(sound_font=sound_font_path)\n    synth.midi_to_audio(tmp_midi_path, wavpath)\n</code></pre>"},{"location":"documentation/rendering/#fortepyan.audio.soundfont.download_if_needed","title":"<code>download_if_needed()</code>","text":"<p>Ensures the SoundFont file is downloaded in the user's data directory.</p> <p>The function checks for 'soundfont.sf2' in the user's data directory, downloading it if absent. The download URL is sourced from the application's configuration.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the SoundFont file.</p> Source code in <code>fortepyan/audio/soundfont.py</code> <pre><code>def download_if_needed() -&gt; Path:\n    \"\"\"\n    Ensures the SoundFont file is downloaded in the user's data directory.\n\n    The function checks for 'soundfont.sf2' in the user's data directory, downloading it if absent.\n    The download URL is sourced from the application's configuration.\n\n    Returns:\n        Path: The path to the SoundFont file.\n    \"\"\"\n    app_name = \"fortepyan\"\n    app_author = \"me\"\n\n    data_dir = appdirs.user_data_dir(app_name, app_author)\n    data_dir = Path(data_dir)\n\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    file_path = data_dir / \"soundfont.sf2\"\n\n    if not file_path.exists():\n        print(\"Downloading SoundFont\")\n        urllib.request.urlretrieve(C.SOUNDFONT_URL, file_path)\n\n    return file_path\n</code></pre>"},{"location":"documentation/sustain/","title":"Sustain","text":"<p>Functions responsible for applying the sustain pedal effect to a MIDI file.</p>"},{"location":"documentation/sustain/#fortepyan.midi.tools.apply_sustain","title":"<code>apply_sustain(df, sustain, sustain_threshold=64)</code>","text":"<p>Apply sustain pedal effects to the notes in a DataFrame.</p> <p>This function uses a second DataFrame containing sustain pedal events to extend the duration of notes in the original DataFrame. It modifies the end times of notes that are held during the time when the sustain pedal is pressed down.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing musical note data. Expected to have columns 'start', 'end', and 'pitch', where 'start' and 'end' represent the start and end times of the notes.</p> required <code>sustain</code> <code>DataFrame</code> <p>The DataFrame containing sustain pedal events. Expected to have columns 'time' and 'value', where 'time' is the timestamp of the pedal event and 'value' is the intensity of the pedal press.</p> required <code>sustain_threshold</code> <code>int</code> <p>The threshold value above which the sustain pedal is considered to be pressed down. Defaults to 64.</p> <code>64</code> <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The modified DataFrame with updated end times for notes affected by the sustain pedal.</p> Notes <ul> <li>The sustain effect is applied by extending the end time of notes to either the   start of the next note with the same pitch or the time when the sustain pedal is   released, whichever comes first.</li> </ul> Source code in <code>fortepyan/midi/tools.py</code> <pre><code>def apply_sustain(\n    df: pd.DataFrame,\n    sustain: pd.DataFrame,\n    sustain_threshold: int = 64,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Apply sustain pedal effects to the notes in a DataFrame.\n\n    This function uses a second DataFrame containing sustain pedal events to extend\n    the duration of notes in the original DataFrame. It modifies the end times of notes\n    that are held during the time when the sustain pedal is pressed down.\n\n    Args:\n        df (pd.DataFrame):\n            The DataFrame containing musical note data. Expected to have columns\n            'start', 'end', and 'pitch', where 'start' and 'end' represent the\n            start and end times of the notes.\n        sustain (pd.DataFrame):\n            The DataFrame containing sustain pedal events. Expected to have columns\n            'time' and 'value', where 'time' is the timestamp of the pedal event and\n            'value' is the intensity of the pedal press.\n        sustain_threshold (int, optional):\n            The threshold value above which the sustain pedal is considered to be pressed\n            down. Defaults to 64.\n\n    Returns:\n        df (pd.DataFrame):\n            The modified DataFrame with updated end times for notes affected by the\n            sustain pedal.\n\n    Notes:\n        - The sustain effect is applied by extending the end time of notes to either the\n          start of the next note with the same pitch or the time when the sustain pedal is\n          released, whichever comes first.\n    \"\"\"\n    # Mark sustain pedal as down or up based on threshold value\n    sustain[\"is_down\"] = sustain.value &gt;= sustain_threshold\n\n    # Group sustain pedal events by continuous down or up states\n    ids = sustain.is_down\n    sustain[\"down_index\"] = (ids != ids.shift(1)).cumsum()\n    groups = sustain[sustain.is_down].groupby(\"down_index\")\n\n    # Iterate over each group of sustain pedal down events\n    for _, gdf in groups:\n        # Get start and end times for current sustain pedal down event\n        pedal_down = gdf.time.min()\n        pedal_up = gdf.time.max()\n\n        # Select notes affected by current sustain pedal down event\n        # ids = (df.end &gt;= pedal_down) &amp; (df.end &lt; pedal_up)\n        # affeced_notes = df[ids]\n\n        # Modify end times of selected notes based on sustain pedal duration\n        df = sustain_notes(\n            df=df,\n            pedal_down=pedal_down,\n            pedal_up=pedal_up,\n        )\n\n    # Keep duration consistent\n    df[\"duration\"] = df.end - df.start\n\n    return df\n</code></pre>"},{"location":"documentation/sustain/#fortepyan.midi.tools.note_number_to_name","title":"<code>note_number_to_name(note_number)</code>","text":"<p>Convert a MIDI note number to its name, in the format <code>'(note)(accidental)(octave number)'</code> (e.g. <code>'C#4'</code>).</p> <p>Parameters:</p> Name Type Description Default <code>note_number</code> <code>int</code> <p>MIDI note number.  If not an int, it will be rounded.</p> required <p>Returns:</p> Name Type Description <code>note_name</code> <code>str</code> <p>Name of the supplied MIDI note number.</p> Source code in <code>fortepyan/midi/tools.py</code> <pre><code>def note_number_to_name(note_number):\n    \"\"\"\n    Convert a MIDI note number to its name, in the format\n    ``'(note)(accidental)(octave number)'`` (e.g. ``'C#4'``).\n\n    Parameters:\n        note_number (int):\n            MIDI note number.  If not an int, it will be rounded.\n\n    Returns:\n        note_name (str):\n            Name of the supplied MIDI note number.\n\n    \"\"\"\n\n    # Note names within one octave\n    semis = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n    # Ensure the note is an int\n    note_number = int(np.round(note_number))\n\n    # Get the semitone and the octave, and concatenate to create the name\n    return semis[note_number % 12] + str(note_number // 12 - 1)\n</code></pre>"},{"location":"documentation/sustain/#fortepyan.midi.tools.sustain_notes","title":"<code>sustain_notes(df, pedal_down, pedal_up)</code>","text":"<p>Extend the end times of notes affected by a sustain pedal down event.</p> <p>This helper function is called by <code>apply_sustain</code> to process each group of sustain pedal down events. It extends the end times of notes that are playing during the sustain pedal down event.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing musical note data. Expected to have columns 'start', 'end', and 'pitch'.</p> required <code>pedal_down</code> <code>float</code> <p>The start time of the sustain pedal down event.</p> required <code>pedal_up</code> <code>float</code> <p>The end time of the sustain pedal down event, indicating when the pedal is released.</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The DataFrame with updated end times for the notes affected by the sustain pedal.</p> Source code in <code>fortepyan/midi/tools.py</code> <pre><code>def sustain_notes(\n    df: pd.DataFrame,\n    pedal_down: float,\n    pedal_up: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Extend the end times of notes affected by a sustain pedal down event.\n\n    This helper function is called by `apply_sustain` to process each group of sustain\n    pedal down events. It extends the end times of notes that are playing during the\n    sustain pedal down event.\n\n    Args:\n        df (pd.DataFrame):\n            The DataFrame containing musical note data. Expected to have columns\n            'start', 'end', and 'pitch'.\n        pedal_down (float):\n            The start time of the sustain pedal down event.\n        pedal_up (float):\n            The end time of the sustain pedal down event, indicating when the pedal is released.\n\n    Returns:\n        df (pd.DataFrame):\n            The DataFrame with updated end times for the notes affected by the sustain pedal.\n    \"\"\"\n    end_times = []\n\n    # Select notes affected by current sustain pedal down event\n    ids = (df.end &gt;= pedal_down) &amp; (df.end &lt; pedal_up)\n    affected_notes = df[ids]\n\n    for it, row in affected_notes.iterrows():\n        # Get the rows in the DataFrame that correspond to the same pitch\n        # as the current row, and that start after the current row\n        jds = (df.pitch == row.pitch) &amp; (df.start &gt; row.start)\n\n        if jds.any():\n            # If there are any such rows, set the end time\n            # to be the start time of the next note of the same pitch\n            end_time = min(df[jds].start.min(), pedal_up)\n        else:\n            # If there are no such rows, set the end time to be the end of the sustain\n            # or to be the release of the note, whichever is later\n            end_time = max(row.end, pedal_up)\n\n        end_times.append(end_time)\n\n    df.loc[ids, \"end\"] = end_times\n\n    return df\n</code></pre>"},{"location":"documentation/visualization/","title":"Classes and functions used for visualization","text":""},{"location":"documentation/visualization/#fortepyan.view.pianoroll.structures.DualPianoRoll","title":"<code>DualPianoRoll</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PianoRoll</code></p> <p>Extends the PianoRoll class to represent a dual-layer piano roll visualization.</p> <p>The DualPianoRoll class enhances the basic piano roll visualization by allowing for the representation of additional information, such as masking in machine learning contexts, through the use of dual color mapping.</p> <p>Attributes:</p> Name Type Description <code>base_cmap</code> <code>Union[str, ListedColormap]</code> <p>The colormap for the base layer of the piano roll.</p> <code>marked_cmap</code> <code>Union[str, ListedColormap]</code> <p>The colormap for the marked layer of the piano roll.</p> <code>mark_key</code> <code>str</code> <p>The key used to determine markings in the MIDI data.</p> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Initializes the dual-layer piano roll with specified colormaps.</p> <code>_build_image</code> <p>Builds the dual-layer piano roll image from the MIDI data, applying color mappings.</p> Source code in <code>fortepyan/view/pianoroll/structures.py</code> <pre><code>@dataclass\nclass DualPianoRoll(PianoRoll):\n    \"\"\"\n    Extends the PianoRoll class to represent a dual-layer piano roll visualization.\n\n    The DualPianoRoll class enhances the basic piano roll visualization by allowing for the\n    representation of additional information, such as masking in machine learning contexts, through\n    the use of dual color mapping.\n\n    Attributes:\n        base_cmap (Union[str, ListedColormap]): The colormap for the base layer of the piano roll.\n        marked_cmap (Union[str, ListedColormap]): The colormap for the marked layer of the piano roll.\n        mark_key (str): The key used to determine markings in the MIDI data.\n\n    Methods:\n        __post_init__(): Initializes the dual-layer piano roll with specified colormaps.\n        _build_image(): Builds the dual-layer piano roll image from the MIDI data, applying color mappings.\n    \"\"\"\n\n    base_cmap: Union[str, ListedColormap] = field(default_factory=cm.devon_r)\n    marked_cmap: Union[str, ListedColormap] = \"RdPu\"\n    mark_key: str = \"mask\"\n\n    def __post_init__(self):\n        # Strings are for the standard set of colormaps\n        # ListedColormap is for custom solutions (e.g.: cmcrameri)\n        if isinstance(self.base_cmap, ListedColormap):\n            self.base_colormap = self.base_cmap\n        else:\n            self.base_colormap = matplotlib.colormaps[self.base_cmap]\n\n        if isinstance(self.marked_cmap, matplotlib.colors.ListedColormap):\n            self.marked_colormap = self.marked_cmap\n        else:\n            self.marked_colormap = matplotlib.colormaps[self.marked_cmap]\n        super().__post_init__()\n\n    def _build_image(self):\n        df = self.midi_piece.df_with_end\n        if not self.time_end:\n            # We don't really need a full second roundup\n            self.time_end = np.ceil(df.end.max())\n\n        if self.time_end &lt; df.end.max():\n            showwarning(\"Warning, piano roll is not showing everything!\", UserWarning, \"pianoroll.py\", 164)\n\n        # duration = time_end - time_start\n        self.duration = self.time_end\n        n_time_steps = self.RESOLUTION * int(np.ceil(self.duration))\n\n        # Adjust velocity color intensity to be sure it's visible\n        min_value = 20\n        max_value = 160\n\n        # Canvas to draw on\n        background = np.zeros((self.N_PITCHES, n_time_steps), np.uint8)\n\n        # Draw black keys with the base colormap\n        for it in range(self.N_PITCHES):\n            is_black = it % 12 in [1, 3, 6, 8, 10]\n            if is_black:\n                background[it, :] += min_value\n        # This makes the array RGB\n        background = self.base_colormap(background)\n\n        # Draw notes\n        for it, row in df.iterrows():\n            note_on = row.start * self.RESOLUTION\n            note_on = np.round(note_on).astype(int)\n\n            note_end = row.end * self.RESOLUTION\n            note_end = np.round(note_end).astype(int)\n            pitch_idx = int(row.pitch)\n\n            # This note is sounding right now\n            if self.current_time and note_on &lt;= self.current_time * self.RESOLUTION &lt; note_end:\n                color_value = max_value\n            else:\n                color_value = min_value + row.velocity\n\n            # Colormaps are up to 255, but velocity is up to 127\n            color_value += 90\n\n            cmap = self.marked_colormap if row[self.mark_key] else self.base_colormap\n            background[pitch_idx, note_on:note_end] = cmap(color_value)\n\n            # pianoroll[pitch_idx, note_on:note_end] = color_value\n\n        self.roll = background\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.structures.FigureResolution","title":"<code>FigureResolution</code>  <code>dataclass</code>","text":"<p>Represents the resolution configuration for a figure.</p> <p>Attributes:</p> Name Type Description <code>w_pixels</code> <code>int</code> <p>The width of the figure in pixels.</p> <code>h_pixels</code> <code>int</code> <p>The height of the figure in pixels.</p> <code>dpi</code> <code>int</code> <p>The dots per inch (resolution) of the figure.</p> Properties <p>w_inches (float): The width of the figure in inches, calculated from pixels and dpi. h_inches (float): The height of the figure in inches, calculated from pixels and dpi. figsize (tuple[float, float]): The size of the figure as a tuple of width and height in inches.</p> Source code in <code>fortepyan/view/pianoroll/structures.py</code> <pre><code>@dataclass\nclass FigureResolution:\n    \"\"\"\n    Represents the resolution configuration for a figure.\n\n    Attributes:\n        w_pixels (int): The width of the figure in pixels.\n        h_pixels (int): The height of the figure in pixels.\n        dpi (int): The dots per inch (resolution) of the figure.\n\n    Properties:\n        w_inches (float): The width of the figure in inches, calculated from pixels and dpi.\n        h_inches (float): The height of the figure in inches, calculated from pixels and dpi.\n        figsize (tuple[float, float]): The size of the figure as a tuple of width and height in inches.\n    \"\"\"\n\n    w_pixels: int = 1920 // 2\n    h_pixels: int = 1080 // 2\n    dpi: int = 72\n\n    @property\n    def w_inches(self) -&gt; float:\n        return self.w_pixels / self.dpi\n\n    @property\n    def h_inches(self) -&gt; float:\n        return self.h_pixels / self.dpi\n\n    @property\n    def figsize(self) -&gt; tuple[float, float]:\n        return self.w_inches, self.h_inches\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.structures.PianoRoll","title":"<code>PianoRoll</code>  <code>dataclass</code>","text":"<p>Represents a piano roll visualization of a MIDI piece.</p> <p>The PianoRoll class provides a visual representation of MIDI data as a traditional piano roll, which is often used in music software. This representation includes the ability to mark the current time, set start and end times for the visualization, and dynamically build the piano roll image based on the MIDI data.</p> <p>Attributes:</p> Name Type Description <code>midi_piece</code> <code>MidiPiece</code> <p>The MIDI piece to be visualized.</p> <code>current_time</code> <code>float</code> <p>The current time position in the MIDI piece.</p> <code>time_start</code> <code>float</code> <p>The start time for the piano roll visualization.</p> <code>time_end</code> <code>float</code> <p>The end time for the piano roll visualization.</p> <code>roll</code> <code>array</code> <p>The numpy array representing the piano roll image.</p> <code>RESOLUTION</code> <code>int</code> <p>The resolution of the piano roll image.</p> <code>N_PITCHES</code> <code>int</code> <p>The number of pitches to be represented in the piano roll.</p> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Initializes the piano roll image and tick preparations.</p> <code>lowest_pitch</code> <p>Returns the lowest pitch present in the MIDI piece.</p> <code>highest_pitch</code> <p>Returns the highest pitch present in the MIDI piece.</p> <code>_build_image</code> <p>Builds the piano roll image from the MIDI data.</p> <code>_prepare_ticks</code> <p>Prepares the tick marks and labels for the piano roll visualization.</p> Source code in <code>fortepyan/view/pianoroll/structures.py</code> <pre><code>@dataclass\nclass PianoRoll:\n    \"\"\"\n    Represents a piano roll visualization of a MIDI piece.\n\n    The PianoRoll class provides a visual representation of MIDI data as a traditional piano roll,\n    which is often used in music software. This representation includes the ability to mark the current time,\n    set start and end times for the visualization, and dynamically build the piano roll image based on the MIDI data.\n\n    Attributes:\n        midi_piece (MidiPiece): The MIDI piece to be visualized.\n        current_time (float, optional): The current time position in the MIDI piece.\n        time_start (float): The start time for the piano roll visualization.\n        time_end (float, optional): The end time for the piano roll visualization.\n        roll (np.array): The numpy array representing the piano roll image.\n        RESOLUTION (int): The resolution of the piano roll image.\n        N_PITCHES (int): The number of pitches to be represented in the piano roll.\n\n    Methods:\n        __post_init__(): Initializes the piano roll image and tick preparations.\n        lowest_pitch(): Returns the lowest pitch present in the MIDI piece.\n        highest_pitch(): Returns the highest pitch present in the MIDI piece.\n        _build_image(): Builds the piano roll image from the MIDI data.\n        _prepare_ticks(): Prepares the tick marks and labels for the piano roll visualization.\n    \"\"\"\n\n    midi_piece: MidiPiece\n    current_time: float = None\n    time_start: float = 0.0\n    time_end: float = None\n\n    roll: np.array = field(init=False)\n\n    RESOLUTION: int = 30\n    N_PITCHES: int = 128\n\n    def __post_init__(self):\n        self._build_image()\n        self._prepare_ticks()\n\n    @property\n    def lowest_pitch(self) -&gt; int:\n        return self.midi_piece.df.pitch.min()\n\n    @property\n    def highest_pitch(self) -&gt; int:\n        return self.midi_piece.df.pitch.max()\n\n    def _build_image(self):\n        df = self.midi_piece.df_with_end\n        if not self.time_end:\n            # We don't really need a full second roundup\n            self.time_end = np.ceil(df.end.max())\n\n        if self.time_end &lt; df.end.max():\n            print(\"Warning, piano roll is not showing everything!\")\n\n        # duration = time_end - time_start\n        self.duration = self.time_end\n        n_time_steps = self.RESOLUTION * int(np.ceil(self.duration))\n        pianoroll = np.zeros((self.N_PITCHES, n_time_steps), np.uint8)\n\n        # Adjust velocity color intensity to be sure it's visible\n        min_value = 20\n        max_value = 160\n\n        for it, row in df.iterrows():\n            note_on = row.start * self.RESOLUTION\n            note_on = np.round(note_on).astype(int)\n\n            note_end = row.end * self.RESOLUTION\n            note_end = np.round(note_end).astype(int)\n            pitch_idx = int(row.pitch)\n\n            # This note is sounding right now\n            if self.current_time and note_on &lt;= self.current_time * self.RESOLUTION &lt; note_end:\n                color_value = max_value\n            else:\n                color_value = min_value + row.velocity\n            pianoroll[pitch_idx, note_on:note_end] = color_value\n\n        # Could be a part of \"prepare empty piano roll\"\n        for it in range(self.N_PITCHES):\n            is_black = it % 12 in [1, 3, 6, 8, 10]\n            if is_black:\n                pianoroll[it, :] += min_value\n\n        self.roll = pianoroll\n\n    def _prepare_ticks(self):\n        self.y_ticks = np.arange(0, 128, 12, dtype=float)\n\n        # Adding new line shifts the label up a little and positions\n        # it nicely at the height where the note actually is\n        self.pitch_labels = [f\"{note_number_to_name(it)}\\n\" for it in self.y_ticks]\n\n        # Move the ticks to land between the notes\n        # (each note is 1-width and ticks by default are centered, ergo: 0.5 shift)\n        self.y_ticks -= 0.5\n\n        # Prepare x ticks and labels\n        n_ticks = min(30, self.duration)\n        step = np.ceil(self.duration / n_ticks)\n        x_ticks = np.arange(0, step * n_ticks, step)\n        self.x_ticks = np.round(x_ticks)\n        self.x_labels = [round(xt) for xt in self.x_ticks]\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.main.draw_piano_roll","title":"<code>draw_piano_roll(ax, piano_roll, time=0.0, cmap='GnBu')</code>","text":"<p>Draws a piano roll visualization on a Matplotlib axis.</p> <p>This function visualizes the piano roll of a MIDI piece on a given Matplotlib axis. It includes options to highlight notes played at a specific time and to customize the color mapping.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Matplotlib axis on which to draw the piano roll.</p> required <code>piano_roll</code> <code>PianoRoll</code> <p>The PianoRoll object representing the MIDI piece.</p> required <code>time</code> <code>float</code> <p>The specific time at which to highlight notes. Defaults to 0.0.</p> <code>0.0</code> <code>cmap</code> <code>str</code> <p>The color map to use for the visualization. Defaults to \"GnBu\".</p> <code>'GnBu'</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: The modified Matplotlib axis with the piano roll visualization.</p> Source code in <code>fortepyan/view/pianoroll/main.py</code> <pre><code>def draw_piano_roll(\n    ax: plt.Axes,\n    piano_roll: PianoRoll,\n    time: float = 0.0,\n    cmap: str = \"GnBu\",\n) -&gt; plt.Axes:\n    \"\"\"\n    Draws a piano roll visualization on a Matplotlib axis.\n\n    This function visualizes the piano roll of a MIDI piece on a given Matplotlib axis. It includes options to highlight\n    notes played at a specific time and to customize the color mapping.\n\n    Args:\n        ax (plt.Axes): The Matplotlib axis on which to draw the piano roll.\n        piano_roll (PianoRoll): The PianoRoll object representing the MIDI piece.\n        time (float, optional): The specific time at which to highlight notes. Defaults to 0.0.\n        cmap (str): The color map to use for the visualization. Defaults to \"GnBu\".\n\n    Returns:\n        plt.Axes: The modified Matplotlib axis with the piano roll visualization.\n    \"\"\"\n    ax.imshow(\n        piano_roll.roll,\n        aspect=\"auto\",\n        vmin=0,\n        vmax=138,\n        origin=\"lower\",\n        interpolation=\"none\",\n        cmap=cmap,\n    )\n\n    ax.set_yticks(piano_roll.y_ticks)\n    ax.set_yticklabels(piano_roll.pitch_labels, fontsize=15)\n\n    # Show keyboard range where the music is\n    y_min = piano_roll.lowest_pitch - 1\n    y_max = piano_roll.highest_pitch + 1\n    ax.set_ylim(y_min, y_max)\n\n    ax.set_xticks(piano_roll.x_ticks * piano_roll.RESOLUTION)\n    ax.set_xticklabels(piano_roll.x_labels, rotation=60)\n    ax.set_xlabel(\"Time [s]\")\n    ax.set_xlim(0, piano_roll.duration * piano_roll.RESOLUTION)\n    ax.grid()\n\n    # Vertical position indicator\n    if piano_roll.current_time:\n        ax.axvline(piano_roll.current_time * piano_roll.RESOLUTION, color=\"k\", lw=0.5)\n\n    return ax\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.main.draw_pianoroll_with_velocities","title":"<code>draw_pianoroll_with_velocities(midi_piece, time_end=None, title=None, cmap='GnBu', figres=None)</code>","text":"<p>Draws a pianoroll representation of a MIDI piece with an additional plot for velocities.</p> <p>This function creates a two-part plot with the upper part displaying the pianoroll and the lower part showing the velocities of the notes. Customizable aspects include the end time for the plot, the title, color mapping, and figure resolution.</p> <p>Parameters:</p> Name Type Description Default <code>midi_piece</code> <code>MidiPiece</code> <p>The MIDI piece to be visualized.</p> required <code>time_end</code> <code>float</code> <p>End time for the plot. Defaults to None, meaning full duration is used.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Color map for the pianoroll and velocities. Defaults to \"GnBu\".</p> <code>'GnBu'</code> <code>figres</code> <code>FigureResolution</code> <p>Custom figure resolution settings. Defaults to None,                                   which initiates a default <code>FigureResolution</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>A matplotlib figure object with the pianoroll and velocity plots.</p> Source code in <code>fortepyan/view/pianoroll/main.py</code> <pre><code>def draw_pianoroll_with_velocities(\n    midi_piece: MidiPiece,\n    time_end: float = None,\n    title: str = None,\n    cmap: str = \"GnBu\",\n    figres: FigureResolution = None,\n):\n    \"\"\"\n    Draws a pianoroll representation of a MIDI piece with an additional plot for velocities.\n\n    This function creates a two-part plot with the upper part displaying the pianoroll and the lower part showing\n    the velocities of the notes. Customizable aspects include the end time for the plot, the title, color mapping,\n    and figure resolution.\n\n    Args:\n        midi_piece (MidiPiece): The MIDI piece to be visualized.\n        time_end (float, optional): End time for the plot. Defaults to None, meaning full duration is used.\n        title (str, optional): Title for the plot. Defaults to None.\n        cmap (str): Color map for the pianoroll and velocities. Defaults to \"GnBu\".\n        figres (FigureResolution, optional): Custom figure resolution settings. Defaults to None,\n                                              which initiates a default `FigureResolution`.\n\n    Returns:\n        fig (plt.Figure): A matplotlib figure object with the pianoroll and velocity plots.\n    \"\"\"\n    if not figres:\n        figres = FigureResolution()\n\n    fig, axes = plt.subplots(\n        nrows=2,\n        ncols=1,\n        figsize=figres.figsize,\n        dpi=figres.dpi,\n        gridspec_kw={\n            \"height_ratios\": [4, 1],\n            \"hspace\": 0,\n        },\n    )\n    piece = sanitize_midi_piece(midi_piece)\n    piano_roll = PianoRoll(piece, time_end=time_end)\n    draw_piano_roll(ax=axes[0], piano_roll=piano_roll, cmap=cmap)\n    v_ax = axes[1]\n    draw_velocities(ax=v_ax, piano_roll=piano_roll, cmap=cmap)\n\n    if title:\n        axes[0].set_title(title, fontsize=20)\n\n    # Set the x-axis tick positions and labels, and add a label to the x-axis\n    v_ax.set_xticks(piano_roll.x_ticks)\n    v_ax.set_xticklabels(piano_roll.x_labels, rotation=60, fontsize=15)\n    v_ax.set_xlabel(\"Time [s]\")\n    # Set the x-axis limits to the range of the data\n    v_ax.set_xlim(0, piano_roll.duration)\n\n    return fig\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.main.draw_velocities","title":"<code>draw_velocities(ax, piano_roll, cmap='GnBu')</code>","text":"<p>Draws a velocity plot for a MIDI piece on a Matplotlib axis.</p> <p>This function visualizes the velocities of notes in a MIDI piece using a scatter and line plot. The color and style of the plot can be customized using a colormap.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Matplotlib axis on which to draw the velocity plot.</p> required <code>piano_roll</code> <code>PianoRoll</code> <p>The PianoRoll object representing the MIDI piece.</p> required <code>cmap</code> <code>str</code> <p>The color map to use for the visualization. Defaults to \"GnBu\".</p> <code>'GnBu'</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: The modified Matplotlib axis with the velocity plot.</p> Source code in <code>fortepyan/view/pianoroll/main.py</code> <pre><code>def draw_velocities(\n    ax: plt.Axes,\n    piano_roll: PianoRoll,\n    cmap: str = \"GnBu\",\n) -&gt; plt.Axes:\n    \"\"\"\n    Draws a velocity plot for a MIDI piece on a Matplotlib axis.\n\n    This function visualizes the velocities of notes in a MIDI piece using a scatter and line plot. The color and\n    style of the plot can be customized using a colormap.\n\n    Args:\n        ax (plt.Axes): The Matplotlib axis on which to draw the velocity plot.\n        piano_roll (PianoRoll): The PianoRoll object representing the MIDI piece.\n        cmap (str): The color map to use for the visualization. Defaults to \"GnBu\".\n\n    Returns:\n        plt.Axes: The modified Matplotlib axis with the velocity plot.\n    \"\"\"\n    df = piano_roll.midi_piece.df\n    colormap = matplotlib.colormaps.get_cmap(cmap)\n    color = colormap(125 / 127)\n\n    ax.plot(df.start, df.velocity, \"o\", ms=7, color=color)\n    ax.plot(df.start, df.velocity, \".\", color=\"white\")\n    ax.vlines(\n        df.start,\n        ymin=0,\n        ymax=df.velocity,\n        lw=2,\n        alpha=0.777,\n        colors=color,\n    )\n    ax.set_ylim(0, 128)\n    # Add a grid to the plot\n    ax.grid()\n\n    # Vertical position indicator\n    if piano_roll.current_time:\n        ax.axvline(piano_roll.current_time, color=\"k\", lw=0.5)\n\n    return ax\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.main.sanitize_midi_piece","title":"<code>sanitize_midi_piece(piece)</code>","text":"<p>Trims a MIDI piece to a maximum duration threshold for manageability.</p> <p>If the duration of the MIDI piece exceeds a predefined threshold, it trims the piece to fit within this limit. This function is useful to avoid excessively long playtimes which might be impractical for visualization or analysis.</p> <p>Parameters:</p> Name Type Description Default <code>piece</code> <code>MidiPiece</code> <p>The MIDI piece to be sanitized.</p> required <p>Returns:</p> Name Type Description <code>MidiPiece</code> <code>MidiPiece</code> <p>The sanitized MIDI piece, trimmed if necessary.</p> Source code in <code>fortepyan/view/pianoroll/main.py</code> <pre><code>def sanitize_midi_piece(piece: MidiPiece) -&gt; MidiPiece:\n    \"\"\"\n    Trims a MIDI piece to a maximum duration threshold for manageability.\n\n    If the duration of the MIDI piece exceeds a predefined threshold, it trims the piece to fit within this limit.\n    This function is useful to avoid excessively long playtimes which might be impractical for visualization or analysis.\n\n    Args:\n        piece (MidiPiece): The MIDI piece to be sanitized.\n\n    Returns:\n        MidiPiece: The sanitized MIDI piece, trimmed if necessary.\n    \"\"\"\n    duration_threshold = 1200\n    if piece.duration &gt; duration_threshold:\n        # TODO Logger\n        showwarning(\n            message=\"playtime too long! Showing after trim\",\n            category=RuntimeWarning,\n            filename=\"fortepyan/view/pianoroll/main.py\",\n            lineno=88,\n        )\n        piece = piece.trim(\n            start=0,\n            finish=duration_threshold,\n        )\n\n    return piece\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.pianoroll.main.sanitize_xticks","title":"<code>sanitize_xticks(ax, piece)</code>","text":"<p>Adjusts the x-axis ticks and labels for a MIDI piece plot for improved readability.</p> <p>This function computes and sets appropriate tick marks and labels on the x-axis of a Matplotlib plot based on the duration of a MIDI piece. It ensures the plot is easy to read and interpret by adjusting the frequency and format of the x-axis ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Matplotlib axes object to be modified.</p> required <code>piece</code> <code>MidiPiece</code> <p>The MIDI piece based on which the axis ticks and labels are adjusted.</p> required Source code in <code>fortepyan/view/pianoroll/main.py</code> <pre><code>def sanitize_xticks(ax: plt.Axes, piece: MidiPiece):\n    \"\"\"\n    Adjusts the x-axis ticks and labels for a MIDI piece plot for improved readability.\n\n    This function computes and sets appropriate tick marks and labels on the x-axis of a Matplotlib plot based on the\n    duration of a MIDI piece. It ensures the plot is easy to read and interpret by adjusting the frequency and format\n    of the x-axis ticks.\n\n    Args:\n        ax (plt.Axes): The Matplotlib axes object to be modified.\n        piece (MidiPiece): The MIDI piece based on which the axis ticks and labels are adjusted.\n    \"\"\"\n    # Calculate the number of seconds in the plot\n    n_seconds = np.ceil(piece.duration)\n    # Set the maximum number of x-axis ticks to 30\n    n_ticks = min(30, n_seconds)\n    # Calculate the step size for the x-axis tick positions\n    step = np.ceil(n_seconds / n_ticks)\n    # Calculate the x-axis tick positions\n    x_ticks = np.arange(0, step * n_ticks, step)\n    # Round the x-axis tick positions to the nearest integer\n    x_ticks = np.round(x_ticks)\n    # Set the x-axis tick labels to the same values as the tick positions\n    labels = [xt for xt in x_ticks]\n\n    # Set the x-axis tick positions and labels, and add a label to the x-axis\n    ax.set_xticks(x_ticks)\n    ax.set_xticklabels(labels, rotation=60, fontsize=15)\n    ax.set_xlabel(\"Time [s]\")\n    # Set the x-axis limits to the range of the data\n    ax.set_xlim(0, n_seconds)\n    # Add a grid to the plot\n    ax.grid()\n</code></pre>"},{"location":"documentation/visualization/#classes-used-for-animated-visualizations-of-piano-rolls","title":"Classes used for animated visualizations of piano rolls.","text":""},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene","title":"<code>PianoRollScene</code>","text":"<p>A class for creating and managing the scene of a piano roll animation.</p> <p>Attributes:</p> Name Type Description <code>piece</code> <code>MidiPiece</code> <p>The MIDI piece to be visualized.</p> <code>title</code> <code>str</code> <p>Title of the piano roll scene.</p> <code>cmap</code> <code>str</code> <p>Color map used for the visualization, default is \"GnBu\".</p> <code>axes</code> <code>list</code> <p>List containing the matplotlib axes for the piano roll and velocity plots.</p> <code>content_dir</code> <code>Path</code> <p>Directory path for storing temporary files.</p> <code>frame_paths</code> <code>list</code> <p>List of paths where individual frame images are saved.</p> <code>figure</code> <code>Figure</code> <p>The matplotlib figure object for the scene.</p> <code>roll_ax</code> <code>Axes</code> <p>The axes for the piano roll plot.</p> <code>velocity_ax</code> <code>Axes</code> <p>The axes for the velocity plot.</p> <p>Parameters:</p> Name Type Description Default <code>piece</code> <code>MidiPiece</code> <p>The MIDI piece to be visualized.</p> required <code>title</code> <code>str</code> <p>Title of the piano roll scene.</p> required <code>cmap</code> <code>str</code> <p>Color map used for the visualization. Defaults to \"GnBu\".</p> <code>'GnBu'</code> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>class PianoRollScene:\n    \"\"\"\n    A class for creating and managing the scene of a piano roll animation.\n\n    Attributes:\n        piece (MidiPiece): The MIDI piece to be visualized.\n        title (str): Title of the piano roll scene.\n        cmap (str): Color map used for the visualization, default is \"GnBu\".\n        axes (list): List containing the matplotlib axes for the piano roll and velocity plots.\n        content_dir (Path): Directory path for storing temporary files.\n        frame_paths (list): List of paths where individual frame images are saved.\n        figure (matplotlib.figure.Figure): The matplotlib figure object for the scene.\n        roll_ax (matplotlib.axes.Axes): The axes for the piano roll plot.\n        velocity_ax (matplotlib.axes.Axes): The axes for the velocity plot.\n\n    Args:\n        piece (MidiPiece): The MIDI piece to be visualized.\n        title (str): Title of the piano roll scene.\n        cmap (str, optional): Color map used for the visualization. Defaults to \"GnBu\".\n    \"\"\"\n\n    def __init__(self, piece: MidiPiece, title: str, cmap: str = \"GnBu\"):\n        self.axes = []\n        self.content_dir = Path(tempfile.mkdtemp())\n\n        self.frame_paths = []\n\n        self.piece = piece\n        self.title = title\n        self.cmap = cmap\n\n        figres = FigureResolution()\n        f, axes = plt.subplots(\n            nrows=2,\n            ncols=1,\n            figsize=figres.figsize,\n            dpi=figres.dpi,\n            gridspec_kw={\n                \"height_ratios\": [4, 1],\n                \"hspace\": 0,\n            },\n        )\n\n        self.figure = f\n        self.roll_ax = axes[0]\n        self.velocity_ax = axes[1]\n        self.axes = [self.roll_ax, self.velocity_ax]\n\n    def draw_all_axes(self, time: float) -&gt; None:\n        \"\"\"\n        Draws both the piano roll and velocity plots at a specified time.\n\n        Args:\n            time (float): The time at which to draw the plots.\n        \"\"\"\n        self.draw_piano_roll(time)\n        self.draw_velocities(time)\n\n    def draw_piano_roll(self, time: float) -&gt; None:\n        \"\"\"\n        Draws the piano roll plot at a specified time.\n\n        Args:\n            time (float): The time at which to draw the piano roll.\n        \"\"\"\n        piano_roll = PianoRoll(self.piece, current_time=time)\n        roll.draw_piano_roll(\n            ax=self.roll_ax,\n            piano_roll=piano_roll,\n            cmap=self.cmap,\n            time=time,\n        )\n        self.roll_ax.set_title(self.title, fontsize=20)\n\n    def draw_velocities(self, time: float) -&gt; None:\n        \"\"\"\n        Draws the velocity plot at a specified time.\n\n        Args:\n            time (float): The time at which to draw the velocity plot.\n        \"\"\"\n        piano_roll = PianoRoll(self.piece)\n        roll.draw_velocities(\n            ax=self.velocity_ax,\n            piano_roll=piano_roll,\n            cmap=self.cmap,\n        )\n\n        # Set the x-axis tick positions and labels, and add a label to the x-axis\n        self.velocity_ax.set_xticks(piano_roll.x_ticks)\n        self.velocity_ax.set_xticklabels(piano_roll.x_labels, rotation=60, fontsize=15)\n        self.velocity_ax.set_xlabel(\"Time [s]\")\n        # Set the x-axis limits to the range of the data\n        self.velocity_ax.set_xlim(0, piano_roll.duration)\n\n    def save_frame(self, savepath: str = \"tmp/tmp.png\") -&gt; None:\n        \"\"\"\n        Saves the current state of the figure to a file.\n\n        Args:\n            savepath (str, optional): Path where the image should be saved. Defaults to \"tmp/tmp.png\".\n        \"\"\"\n        self.figure.tight_layout()\n\n        self.figure.savefig(savepath)\n\n        self.clean_figure()\n\n    def clean_figure(self) -&gt; None:\n        \"\"\"\n        Clears the content of all axes in the figure.\n        \"\"\"\n        for ax in self.axes:\n            ax.clear()\n\n    def animate_part(self, part: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Animates a part of the MIDI piece.\n\n        Args:\n            part (pd.DataFrame): DataFrame containing time and counter information for frames.\n        \"\"\"\n        for it, row in part.iterrows():\n            time = row.time\n            frame_counter = int(row.counter)\n            self.draw(time)\n            savepath = self.content_dir / f\"{100000 + frame_counter}.png\"\n            self.save_frame(savepath)\n            self.frame_paths.append(savepath)\n\n    def draw(self, time: float) -&gt; None:\n        \"\"\"\n        Prepares the figure for drawing and invokes drawing of all axes for a specific time.\n\n        Args:\n            time (float): The time at which to draw the figure.\n        \"\"\"\n        self.clean_figure()\n        self.figure.tight_layout()\n        self.draw_all_axes(time)\n\n    def prepare_animation_steps(self, framerate: int = 30) -&gt; pd.DataFrame:\n        \"\"\"\n        Prepare the data required for the animation.\n\n        Parameters:\n            framerate (int): Framerate for the animation (default is 30).\n\n        Returns:\n            pd.DataFrame: DataFrame containing time and counter for each frame.\n        \"\"\"\n        # Calculate the maximum time required for the animation\n        max_time = np.ceil(self.piece.df.end.max()).astype(int)\n        # Calculate the number of frames required for the animation\n        n_frames = max_time * framerate\n        # Create an array of times that will be used to create the animation\n        times = np.linspace(0, max_time - 1 / framerate, n_frames)\n        # Create a DataFrame to store the time and counter for each frame\n        df = pd.DataFrame({\"time\": times, \"counter\": range(n_frames)})\n\n        return df\n\n    def render(self, framerate: int = 30) -&gt; Path:\n        \"\"\"\n        Render the animation using a single process.\n\n        Args:\n            framerate (int): Framerate for the animation, defaults to 30.\n\n        Returns:\n            Path: Directory containing the generated animation content.\n        \"\"\"\n        df = self.prepare_animation_steps(framerate)\n\n        # Call the animate_part function with the entire DataFrame as an argument\n        self.animate_part(df)\n\n        # Return the directory containing the generated animation content\n        return self.content_dir\n\n    def render_mp(self, framerate: int = 30) -&gt; Path:\n        \"\"\"\n        Renders the animation using multi-processing to speed up the process.\n\n        Args:\n            framerate (int): Framerate for the animation, defaults to 30.\n\n        Returns:\n            Path: Directory containing the generated animation content.\n        \"\"\"\n        df = self.prepare_animation_steps(framerate)\n\n        # Step size for dividing the DataFrame into parts\n        step = 50\n\n        # Divide the DataFrame into parts based on the step size\n        parts = [df[sta : sta + step] for sta in range(0, df.shape[0], step)]\n\n        # Create a pool of processes using all available CPU cores\n        with mp.Pool(mp.cpu_count()) as pool:\n            # Map the animate_part function to each part of the DataFrame\n            pool.map(self.animate_part, parts)\n\n        # Return the directory containing the generated animation content\n        return self.content_dir\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.animate_part","title":"<code>animate_part(part)</code>","text":"<p>Animates a part of the MIDI piece.</p> <p>Parameters:</p> Name Type Description Default <code>part</code> <code>DataFrame</code> <p>DataFrame containing time and counter information for frames.</p> required Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def animate_part(self, part: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Animates a part of the MIDI piece.\n\n    Args:\n        part (pd.DataFrame): DataFrame containing time and counter information for frames.\n    \"\"\"\n    for it, row in part.iterrows():\n        time = row.time\n        frame_counter = int(row.counter)\n        self.draw(time)\n        savepath = self.content_dir / f\"{100000 + frame_counter}.png\"\n        self.save_frame(savepath)\n        self.frame_paths.append(savepath)\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.clean_figure","title":"<code>clean_figure()</code>","text":"<p>Clears the content of all axes in the figure.</p> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def clean_figure(self) -&gt; None:\n    \"\"\"\n    Clears the content of all axes in the figure.\n    \"\"\"\n    for ax in self.axes:\n        ax.clear()\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.draw","title":"<code>draw(time)</code>","text":"<p>Prepares the figure for drawing and invokes drawing of all axes for a specific time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which to draw the figure.</p> required Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def draw(self, time: float) -&gt; None:\n    \"\"\"\n    Prepares the figure for drawing and invokes drawing of all axes for a specific time.\n\n    Args:\n        time (float): The time at which to draw the figure.\n    \"\"\"\n    self.clean_figure()\n    self.figure.tight_layout()\n    self.draw_all_axes(time)\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.draw_all_axes","title":"<code>draw_all_axes(time)</code>","text":"<p>Draws both the piano roll and velocity plots at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which to draw the plots.</p> required Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def draw_all_axes(self, time: float) -&gt; None:\n    \"\"\"\n    Draws both the piano roll and velocity plots at a specified time.\n\n    Args:\n        time (float): The time at which to draw the plots.\n    \"\"\"\n    self.draw_piano_roll(time)\n    self.draw_velocities(time)\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.draw_piano_roll","title":"<code>draw_piano_roll(time)</code>","text":"<p>Draws the piano roll plot at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which to draw the piano roll.</p> required Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def draw_piano_roll(self, time: float) -&gt; None:\n    \"\"\"\n    Draws the piano roll plot at a specified time.\n\n    Args:\n        time (float): The time at which to draw the piano roll.\n    \"\"\"\n    piano_roll = PianoRoll(self.piece, current_time=time)\n    roll.draw_piano_roll(\n        ax=self.roll_ax,\n        piano_roll=piano_roll,\n        cmap=self.cmap,\n        time=time,\n    )\n    self.roll_ax.set_title(self.title, fontsize=20)\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.draw_velocities","title":"<code>draw_velocities(time)</code>","text":"<p>Draws the velocity plot at a specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time at which to draw the velocity plot.</p> required Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def draw_velocities(self, time: float) -&gt; None:\n    \"\"\"\n    Draws the velocity plot at a specified time.\n\n    Args:\n        time (float): The time at which to draw the velocity plot.\n    \"\"\"\n    piano_roll = PianoRoll(self.piece)\n    roll.draw_velocities(\n        ax=self.velocity_ax,\n        piano_roll=piano_roll,\n        cmap=self.cmap,\n    )\n\n    # Set the x-axis tick positions and labels, and add a label to the x-axis\n    self.velocity_ax.set_xticks(piano_roll.x_ticks)\n    self.velocity_ax.set_xticklabels(piano_roll.x_labels, rotation=60, fontsize=15)\n    self.velocity_ax.set_xlabel(\"Time [s]\")\n    # Set the x-axis limits to the range of the data\n    self.velocity_ax.set_xlim(0, piano_roll.duration)\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.prepare_animation_steps","title":"<code>prepare_animation_steps(framerate=30)</code>","text":"<p>Prepare the data required for the animation.</p> <p>Parameters:</p> Name Type Description Default <code>framerate</code> <code>int</code> <p>Framerate for the animation (default is 30).</p> <code>30</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing time and counter for each frame.</p> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def prepare_animation_steps(self, framerate: int = 30) -&gt; pd.DataFrame:\n    \"\"\"\n    Prepare the data required for the animation.\n\n    Parameters:\n        framerate (int): Framerate for the animation (default is 30).\n\n    Returns:\n        pd.DataFrame: DataFrame containing time and counter for each frame.\n    \"\"\"\n    # Calculate the maximum time required for the animation\n    max_time = np.ceil(self.piece.df.end.max()).astype(int)\n    # Calculate the number of frames required for the animation\n    n_frames = max_time * framerate\n    # Create an array of times that will be used to create the animation\n    times = np.linspace(0, max_time - 1 / framerate, n_frames)\n    # Create a DataFrame to store the time and counter for each frame\n    df = pd.DataFrame({\"time\": times, \"counter\": range(n_frames)})\n\n    return df\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.render","title":"<code>render(framerate=30)</code>","text":"<p>Render the animation using a single process.</p> <p>Parameters:</p> Name Type Description Default <code>framerate</code> <code>int</code> <p>Framerate for the animation, defaults to 30.</p> <code>30</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Directory containing the generated animation content.</p> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def render(self, framerate: int = 30) -&gt; Path:\n    \"\"\"\n    Render the animation using a single process.\n\n    Args:\n        framerate (int): Framerate for the animation, defaults to 30.\n\n    Returns:\n        Path: Directory containing the generated animation content.\n    \"\"\"\n    df = self.prepare_animation_steps(framerate)\n\n    # Call the animate_part function with the entire DataFrame as an argument\n    self.animate_part(df)\n\n    # Return the directory containing the generated animation content\n    return self.content_dir\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.render_mp","title":"<code>render_mp(framerate=30)</code>","text":"<p>Renders the animation using multi-processing to speed up the process.</p> <p>Parameters:</p> Name Type Description Default <code>framerate</code> <code>int</code> <p>Framerate for the animation, defaults to 30.</p> <code>30</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Directory containing the generated animation content.</p> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def render_mp(self, framerate: int = 30) -&gt; Path:\n    \"\"\"\n    Renders the animation using multi-processing to speed up the process.\n\n    Args:\n        framerate (int): Framerate for the animation, defaults to 30.\n\n    Returns:\n        Path: Directory containing the generated animation content.\n    \"\"\"\n    df = self.prepare_animation_steps(framerate)\n\n    # Step size for dividing the DataFrame into parts\n    step = 50\n\n    # Divide the DataFrame into parts based on the step size\n    parts = [df[sta : sta + step] for sta in range(0, df.shape[0], step)]\n\n    # Create a pool of processes using all available CPU cores\n    with mp.Pool(mp.cpu_count()) as pool:\n        # Map the animate_part function to each part of the DataFrame\n        pool.map(self.animate_part, parts)\n\n    # Return the directory containing the generated animation content\n    return self.content_dir\n</code></pre>"},{"location":"documentation/visualization/#fortepyan.view.animation.pianoroll.PianoRollScene.save_frame","title":"<code>save_frame(savepath='tmp/tmp.png')</code>","text":"<p>Saves the current state of the figure to a file.</p> <p>Parameters:</p> Name Type Description Default <code>savepath</code> <code>str</code> <p>Path where the image should be saved. Defaults to \"tmp/tmp.png\".</p> <code>'tmp/tmp.png'</code> Source code in <code>fortepyan/view/animation/pianoroll.py</code> <pre><code>def save_frame(self, savepath: str = \"tmp/tmp.png\") -&gt; None:\n    \"\"\"\n    Saves the current state of the figure to a file.\n\n    Args:\n        savepath (str, optional): Path where the image should be saved. Defaults to \"tmp/tmp.png\".\n    \"\"\"\n    self.figure.tight_layout()\n\n    self.figure.savefig(savepath)\n\n    self.clean_figure()\n</code></pre>"},{"location":"examples/visualizations/","title":"Example usage of Fortepyan","text":"<p>As a first example, we will create a random midi piece and display it as a piano roll.</p> Getting started<pre><code>import pandas as pd\nimport numpy as np\nimport fortepyan as ff\n\nnp.random.seed(42) # Fix the seed for reproducibility\n\n# Create a dataframe with random values\nrandom_df = pd.DataFrame(\n    {\n        \"start\": [i for i in range(0, 100)],\n        \"duration\": [np.random.uniform(0.5, 1.5) for i in range(0, 100)],\n        \"pitch\": [np.random.randint(45, 90) for i in range(0, 100)],\n        \"velocity\": [np.random.randint(45, 90) for i in range(0, 100)],\n    }\n)\nrandom_midi = ff.MidiPiece(random_df) # Create a MidiPiece object\n\n# Let's assume we're interested in notes 5-24\ninteresting_part = random_midi.trim(5, 24, slice_type=\"index\")\nff.view.draw_pianoroll_with_velocities(interesting_part)\n</code></pre> <p>The outcome you should expect is: </p>"}]}